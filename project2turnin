#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.15.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the '#!/bin/sh' line above, then type 'sh FILE'.
#
lock_dir=_sh1458329
# Made on 2021-10-25 21:33 EDT by <n01058529@cisvm-softeng1>.
# Source directory was '/home/n01058529@unfcsd.unf.edu/P2'.
#
# Existing files will *not* be overwritten, unless '-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   1507 -rw-r--r-- directives.c
#   1488 -rw-r--r-- instructions.c
#  23825 -rw-r--r-- main.c
#   1243 -rw-r--r-- symbols.c
#    788 -rw-r--r-- headers.h
#   1153 -rw-r--r-- documentation.txt
#    448 -rw-r--r-- makefile
#
MD5SUM=${MD5SUM-md5sum}
f=`${MD5SUM} --version | egrep '^md5sum .*(core|text)utils'`
test -n "${f}" && md5check=true || md5check=false
${md5check} || \
  echo 'Note: not verifying md5sums.  Consider installing GNU coreutils.'
if test "X$1" = "X-c"
then keep_file=''
else keep_file=true
fi
echo=echo
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=
locale_dir=
set_echo=false

for dir in $PATH
do
  if test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    case `$dir/gettext --version 2>&1 | sed 1q` in
      *GNU*) gettext_dir=$dir
      set_echo=true
      break ;;
    esac
  fi
done

if ${set_echo}
then
  set_echo=false
  for dir in $PATH
  do
    if test -f $dir/shar \
       && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
    then
      locale_dir=`$dir/shar --print-text-domain-dir`
      set_echo=true
      break
    fi
  done

  if ${set_echo}
  then
    TEXTDOMAINDIR=$locale_dir
    export TEXTDOMAINDIR
    TEXTDOMAIN=sharutils
    export TEXTDOMAIN
    echo="$gettext_dir/gettext -s"
  fi
fi
IFS="$save_IFS"
if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null
then if (echo -n test; echo 1,2,3) | grep n >/dev/null
     then shar_n= shar_c='
'
     else shar_n=-n shar_c= ; fi
else shar_n= shar_c='\c' ; fi
f=shar-touch.$$
st1=200112312359.59
st2=123123592001.59
st2tr=123123592001.5 # old SysV 14-char limit
st3=1231235901

if   touch -am -t ${st1} ${f} >/dev/null 2>&1 && \
     test ! -f ${st1} && test -f ${f}; then
  shar_touch='touch -am -t $1$2$3$4$5$6.$7 "$8"'

elif touch -am ${st2} ${f} >/dev/null 2>&1 && \
     test ! -f ${st2} && test ! -f ${st2tr} && test -f ${f}; then
  shar_touch='touch -am $3$4$5$6$1$2.$7 "$8"'

elif touch -am ${st3} ${f} >/dev/null 2>&1 && \
     test ! -f ${st3} && test -f ${f}; then
  shar_touch='touch -am $3$4$5$6$2 "$8"'

else
  shar_touch=:
  echo
  ${echo} 'WARNING: not restoring timestamps.  Consider getting and
installing GNU '\''touch'\'', distributed in GNU coreutils...'
  echo
fi
rm -f ${st1} ${st2} ${st2tr} ${st3} ${f}
#
if test ! -d ${lock_dir} ; then :
else ${echo} "lock directory ${lock_dir} exists"
     exit 1
fi
if mkdir ${lock_dir}
then ${echo} "x - created lock directory ${lock_dir}."
else ${echo} "x - failed to create lock directory ${lock_dir}."
     exit 1
fi
# ============= directives.c ==============
if test -n "${keep_file}" && test -f 'directives.c'
then
${echo} "x - SKIPPING directives.c (file already exists)"

else
${echo} "x - extracting directives.c (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'directives.c' &&
#include "headers.h"
X
X
int IsADirective( char *Test ){
X
return		( 	! ( 
X		 strcmp( Test, "START" )  &&
X		 strcmp( Test, "END" )   &&
X		 strcmp( Test, "RESB" )  &&
X		 strcmp( Test, "RESW" )  &&
X		 strcmp( Test, "RESR" )  &&
X		 strcmp( Test, "BYTE" )  &&
X		 strcmp( Test, "WORD" )  &&
X		 strcmp( Test, "EXPORTS" )   
X
X		 ) ) ;
}
X
int hanStart(char *start,char *startAddr, char lineCopy[1024], int lineNum){
X        int startAddress = 0;
X        char *ptr;
X
X        if( strcmp( start, "START") == 0){
X
X                if( isValidHex( startAddr ) == -1){
X                        printf("\nASSEMBLY ERROR. Line number %d, Line is: %sInvalid hex in start Address \n", lineNum, lineCopy );
X                        return -1;
X                } else if(startAddr < 0){
X                        printf("\nASSEMBLY ERROR. Line number %d, Line is: %sInvalid start address, is below range \n", lineNum, lineCopy );
X                        return -1;
X                } else if ( startAddress >= 32768 ){
X                        printf("\nASSEMBLY ERROR. Line number %d, Line is: %sInvalid start address, is below range \n", lineNum, lineCopy );
X                        return -1;
X                } else{}
X
X
X                  startAddress = strtol (startAddr, &ptr, 16);
X
X                return startAddress;
X        }
X	//printf("%s", start);
X        else{
X             	printf("\nASSEMBLY ERROR. Line number %d, Line is: %sInvalid token for start directive \n", lineNum, lineCopy );
X                return -1;
X        }
}
SHAR_EOF
  (set 20 21 10 17 17 37 27 'directives.c'
   eval "${shar_touch}") && \
  chmod 0644 'directives.c'
if test $? -ne 0
then ${echo} "restore of directives.c failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'directives.c': 'MD5 check failed'
       ) << \SHAR_EOF
a9c5a5dd1b1be91cfc4fdc9a10dea287  directives.c
SHAR_EOF

else
test `LC_ALL=C wc -c < 'directives.c'` -ne 1507 && \
  ${echo} "restoration warning:  size of 'directives.c' is not 1507"
  fi
fi
# ============= instructions.c ==============
if test -n "${keep_file}" && test -f 'instructions.c'
then
${echo} "x - SKIPPING instructions.c (file already exists)"

else
${echo} "x - extracting instructions.c (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'instructions.c' &&
#include "headers.h"
const OPCODE opcode[59] = {
X        { 24, "ADD" }, { 88, "ADDF" }, { 144, "ADDR" }, { 64, "AND" }, { 180, "CLEAR" }, { 40, "COMP" }, { 136, "COMPF" },
X        { 160, "COMPR" }, { 36, "DIV" }, { 100, "DIVF" }, { 156, "DIVR" }, { 196, "FIX" }, { 192, "FLOAT" },
X        { 244, "HIO" }, { 60, "J" },{ 48, "JEQ" }, { 52, "JGT" }, { 56, "JLT" }, { 72, "JSUB" }, { 0, "LDA" },
X        { 104, "LDB" }, { 80, "LDCH" }, { 112, "LDF" }, { 8, "LDL" }, { 108, "LDS" }, { 116, "LDT" }, { 4, "LDX" },
X        { 208, "LPS" }, { 32, "MUL" }, { 96, "MULF" }, { 152, "MULR" }, { 200, "NORM" }, { 68, "OR" }, { 216, "RD" },
X        { 172, "RMO" }, { 76, "RSUB" }, { 164, "SHIFTL" }, { 168, "SHIFTR" }, { 240, "SIO" }, { 236, "SSK" },
X        { 12, "STA" },{ 120, "STB" }, { 84, "STCH" }, { 128, "STF" }, { 212, "STI" }, { 20, "STL" }, { 124, "STS" },
X        { 232, "STSW" }, {132, "STT" }, { 16, "STX" }, { 28, "SUB" }, { 92, "SUBF" }, { 148, "SUBR" }, { 176, "SVC" },
X        { 224, "TD" }, { 248, "TIO" }, { 44, "TIX" }, { 184, "TIXR" }, { 220, "WD" }
};
X
X
int searchOpcode(char *inputOp){
X	
X	int opNum = -1;
X        //printf("Opcode passed in is: %s\n", inputOp);
X
X        for (int i = 0; i <59; i++){
X        	
X		//printf("Opcode table name: %s\n", opcode[i].Name);
X		if(strcmp (opcode[i].Name, inputOp) == 0  ){
X			//printf("\n Opcode number is : %d\n", opcode[i].OpCode);
X			opNum = opcode[i].OpCode; 
X			//return opcode[i].OpCode;				
X		}	
X        	 
X	}
X        return opNum;
}
SHAR_EOF
  (set 20 21 10 17 17 37 27 'instructions.c'
   eval "${shar_touch}") && \
  chmod 0644 'instructions.c'
if test $? -ne 0
then ${echo} "restore of instructions.c failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'instructions.c': 'MD5 check failed'
       ) << \SHAR_EOF
e6ac9057ac08432bc4463bec40fb3575  instructions.c
SHAR_EOF

else
test `LC_ALL=C wc -c < 'instructions.c'` -ne 1488 && \
  ${echo} "restoration warning:  size of 'instructions.c' is not 1488"
  fi
fi
# ============= main.c ==============
if test -n "${keep_file}" && test -f 'main.c'
then
${echo} "x - SKIPPING main.c (file already exists)"

else
${echo} "x - extracting main.c (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'main.c' &&
#include "headers.h"
X
int main(int argc, char *argv[])
{
X
X        FILE *fp;
X        char line[1024];
X        char *newsym;
X        char *nextoken;
X        char *tokens;
X        int endCounter = 0;
X        int lineNumber = 1;
X        int locCtr = 0;
X        int locCtrArr[50];
X        int initAdd = 0;
X        SYMBOL *tab[1024];
X
X        for (int x = 0; x < 1025; x++)
X        {
X                tab[x] = NULL;
X        }
X
X        if (argc != 2)
X        {
X                printf("\nERROR: Usage: %s filename\n", argv[0]);
X                return 0;
X        }
X
X        fp = fopen(argv[1], "r");
X
X        if (fp == NULL)
X        {
X                printf("\nERROR: %s could not be opened for reading,\n", argv[1]);
X                return 0;
X        }
X        newsym = malloc(1024 * sizeof(char));
X        memset(newsym, '\0', 1024 * sizeof(char));
X        nextoken = malloc(1024 * sizeof(char));
X        memset(nextoken, '\0', 1024 * sizeof(char));
X	memset(tab, '\0', 1024 * sizeof(SYMBOL*));
X        //Lines Exist in FP
X        while (fgets(line, 1024, fp) != NULL)
X        {
X
X                if (locCtr == 32768)
X                {
X                        printf("\nASSEMBLY ERROR. line number %d, Line is: %sLocation counter exceeds max amount.\n", lineNumber, line);
X                        return -1;
X                }
X                char lineCopy[1024];
X                strcpy(lineCopy, line);
X
X                //Check for Comment ASCII
X                if (line[0] == 35)
X                {
X                        //printf("COMMENT:%s", line );
X                        continue;
X                }
X
X                //If line contains upperCase Char
X                if ((line[0] >= 65) && (line[0] <= 90))
X                {
X
X                        strcpy(lineCopy, line);
X                        newsym = strtok(line, " \t\n");
X
X                        //CHECK FOR START
X                        if (lineNumber == 1)
X                        {
X                                char *tempSymbol = strtok(NULL, " \t\r\n");
X                                char *tempAddr = strtok(NULL, " \t\r\n");
X                                locCtr = hanStart(tempSymbol, tempAddr, lineCopy, lineNumber);
X                                initAdd = locCtr;
X
X                                if (locCtr == -1)
X                                {
X                                        return -1;
X                                }
X                        }
X
X                        nextoken = strtok(NULL, " \t\n\r");
X
X                        //CHECK FOR VALID SYMBOL
X                        if (IsAValidSymbol(newsym) == 0)
X                        {
X                                printf("\nASSEMBLY ERROR. Line number %d, Line is: %s . INVALID SYMBOL\n", lineNumber, line);
X                                fclose(fp);
X                                return -1;
X                        }
X                        //CHECK IF SYMBOL IS NAMED AFER DIRECTIVE
X                        if (IsADirective(newsym) == 1)
X                        {
X                                printf("\nASSEMBLY ERROR. Line number %d, Line is: %s \n SYMBOL IS NAMED AFTER A DIRECTIVE\n", lineNumber, line);
X                                fclose(fp);
X                                return -1;
X                        }
X
X                        //CHECK IF TOKEN EXISTS AFTER SYMBOL
X                        /* if (nextoken == "\t"){
X                            printf("\nERROR. NO OPCODE/DIRECTIVE AFTER SYMBOL");
X                            return 0;
X                          } */
X
X                        if (checkIfSymbolExits(tab, newsym) == 0)
X                        {
X                                addSymToTab(locCtr, newsym, tab);
X                                locCtrArr[lineNumber] = locCtr;
X                        }
X                        else
X                        {
X                                printf("\n ASSEMBLY ERROR. Line number %d, Line is: %s \n SYMBOL ALREADY EXISISTS IN TABLE. SYMBOL IS : %s \n", lineNumber, line, newsym);
X                                //fclose(fp);
X                                return -1;
X                        }
X
X                        lineNumber++;
X                }
X
X                //IF OPDCODE WITH NO SYMBOL
X                else
X                {
X
X                        //Test LATER
X                        //			printf("This is opcode\n");
X                        if (line[0] != 9)
X                        {
X                                if (IsAValidSymbol(newsym) == 0)
X                                {
X                                        return -1;
X                                }
X                        }
X                        if (strcmp(nextoken, "END") == 0)
X                        {
X                                endCounter++;
X                                if (endCounter == 2)
X                                {
X                                        printf("\nASSEMBLY ERROR. Line number %d, Line is: %sCANNOT HAVE 2 END DIRECTIVES\n", lineNumber, line);
X                                        return -1;
X                                }
X                        }
X                        locCtrArr[lineNumber] = locCtr;
X                        lineNumber++;
X                }
X
X                if (line[0] == 13)
X                {
X                        if (strcmp(nextoken, "END") != 0)
X                        {
X                                printf("\nASSEMBLY ERROR. Line number %d, Line is: %s \n Cannot have empty lines\n", lineNumber, line);
X                                endCounter++;
X                                return -1;
X                        }
X                        else
X                        {
X                                endCounter++;
X                                //printf("/n END COUNTER: %d", endCounter);
X                        }
X                }
X
X                tokens = strtok(lineCopy, " \t\n\r");
X
X                while (tokens)
X                {
X
X                        //printf("\nTOKENS in Loop: %s, NEWSYM: %s\n", tokens,newsym);
X                        //CHECK IF SYMBOL AND TOKEN EQUAL
X                        if (strcmp(newsym, tokens) == 0)
X                        {
X                                tokens = strtok(NULL, " \t\n\r");
X
X                                continue;
X                        }
X
X                        if (strcmp(tokens, "END") == 0)
X                        {
X                                endCounter++;
X                                if (endCounter > 1)
X                                {
X                                        printf("\nASSEMBLY ERROR. Line number %d, Line is: %sMultiple end directives not allowed\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                break;
X                        }
X                        else if (strcmp(tokens, "WORD") == 0)
X                        {
X                                tokens = strtok(NULL, " \t\n\r");
X                                if (tokens == NULL)
X                                {
X                                        printf("ASSEMBLY ERROR. Line number %d, Line is: %sMissing operand after End\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                int word = atoi(tokens);
X                                if (word > 8388608)
X                                {
X                                        printf("ASSEMBLY ERROR. Line number %d, Line is: %sConstant word after directive exceed max word size of 2^23\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                locCtr += 3;
X                                if (locCtr > 1048576)
X                                {
X                                        printf("ASSEMBLY ERROR. Line number %d, Line is: %sMemory has been exceed\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                break;
X                        }
X                        else if (strcmp(tokens, "RESW") == 0)
X                        {
X                                tokens = strtok(NULL, " \t\n\r");
X                                if (tokens == NULL)
X                                {
X                                        printf("ASSEMBLY ERROR.Line number %d, Line is: %sMissing operand after REWS\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                locCtr += 3 * atoi(tokens);
X                                if (locCtr > 1048576)
X                                {
X                                        printf("ASSEMBLY ERROR. Line number %d, Line is: %sMemory has been exceed\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                break;
X                        }
X                        else if (strcmp(tokens, "RESB") == 0)
X                        {
X                                tokens = strtok(NULL, " \t\n\r");
X                                if (tokens == NULL)
X                                {
X                                        printf("ASSEMBLY ERROR. Line number %d, Line is: %sMissing operand after Resb\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                locCtr += atoi(tokens);
X                                if (locCtr > 1048576)
X                                {
X                                        printf("ASSEMBLY ERROR. Line number %d, Line is: %sMemory has been exceed\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                break;
X                        }
X                        else if (strcmp(tokens, "RESR") == 0)
X                        {
X                                locCtr += 3;
X                                if (locCtr > 1048576)
X                                {
X                                        printf("ASSEMBLY ERROR. Line number %d, Line is: %sMemory has been exceed\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                tokens = strtok(NULL, " \t\n\r");
X                                if (tokens == NULL)
X                                {
X                                        printf("ASSEMBLY ERROR. Line number: %d, Line is: %sMISSING OPERAND AFTER RESR\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                break;
X                        }
X                        else if (strcmp(tokens, "EXPORTS") == 0)
X                        {
X                                locCtr += 3;
X                                if (locCtr > 1048576)
X                                {
X                                        printf("ASSEMBLY ERROR. Line number %d, Line is: %sMemory needed, exceeded memory\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                break;
X                        }
X                        else if (strcmp(tokens, "BYTE") == 0)
X                        {
X                                tokens = strtok(NULL, " \t\n\r");
X                                if (tokens == NULL)
X                                {
X                                        printf("ASSEMBLY ERROR. Line number %d, Line is: %sMissing operand after BYTE\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                if (tokens[0] == 'X' && tokens[1] == '\'')
X                                {
X                                        char *hex = strtok(tokens, "X'");
X                                        if (isValidHex(hex) == -1)
X                                        {
X                                                printf("ASSEMBLY ERROR. Line number %d, Line is: %sInvalid Hex in operand BYTE\n", lineNumber, lineCopy);
X                                                return -1;
X                                        }
X                                        locCtr += (strlen(hex)) / 2;
X                                }
X                                else if (tokens[0] == 'C' && tokens[1] == '\'')
X                                {
X                                        char *constant = strtok(tokens, "C'");
X
X                                        locCtr += strlen(constant);
X                                }
X                                else
X                                {
X                                        printf("\tASSEMBLY ERROR. Line number %d, Line is:%s Invalid operand after BYTE\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                if (locCtr > 1048576)
X                                {
X                                        printf("ASSEMBLY ERROR. Line number %d, Line is: %sMemory needed, exceed memory\n", lineNumber, lineCopy);
X                                        return -1;
X                                }
X                                break;
X                        }
X                        else if (strcmp(tokens, "START") == 0)
X                        {
X                                break;
X                        }
X                        //IF NO DIRECTIVES FOUND
X                        else
X                        {
X                                locCtr += 3;
X                                break;
X                        }
X                }
X        }
X
X
X	char *firstSym = NULL;
X	firstSym = malloc(sizeof(firstSym));
X	strcpy(firstSym, tab[0]->Name);
X        
X	/*for (int i = 0; tab[i] != NULL; i++)
X        {
X
X                printf("\n%s,\t %x\n", tab[i]->Name, tab[i]->Address);
X        }*/
X	
X
X        rewind(fp);
X
X	FILE *objFP;
X	objFP = fopen( "objectFile.obj", "w" );
X        int tempLocCtr = 0;
X        int totalLines = lineNumber;
X        lineNumber = 1;
X	int boolCtr[totalLines];
X	char eRecord[7];
X
X
X        while (fgets(line, 1024, fp) != NULL)
X        {
X		boolCtr[lineNumber] = 10;
X                char lineCopy2[1024];
X                char hex[7];
X		
X  		strcpy(lineCopy2, line);
X  		tempLocCtr = 0;
X                char *tokens = strtok(line, " \t\r\n");
X                //printf("\n\nLine Num: %d\n", lineNumber);
X		//printf("\n Line is: %s", lineCopy2); 
X                
X		if (lineCopy2[0] == 35)
X                {
X                        continue;
X                }
X
X                //Retrieve LocCtr
X                for (int i = 0; i < totalLines; i++)
X                {
X                        if (i == lineNumber)
X                        {
X                                tempLocCtr = locCtrArr[i];
X                        }
X                }
X
X
X                //Calcualte H Record
X                if (lineNumber == 1)
X                {
X                        int lenProg = locCtrArr[totalLines - 1] - initAdd;
X                        char headerR[18] = {0};
X                        strcat(headerR, "H");
X			strcpy(firstSym, tokens);
X		       	strcat(headerR, tokens); // SHOULD BE 6 SPACES OF NAME OF PROG (Trailing Spaces)
X                       	strcat(headerR, "  ");
X			sprintf(hex, "%6.6X", initAdd);
X			strcat(headerR, hex); //SHOULD BE 6 SPACE OF START ADDR (Trailing 0)
X                        sprintf(hex, "%6.6X", lenProg);
X			strcat(headerR, hex); //SHOULD BE 6 SAPCES (Prior 00) LENGTH OF PROG
//                      printf("\nH record: %s\n", headerR);
X                        fputs(headerR, objFP);
X			fputs("\n", objFP);
X			//FIX LENGTH OF EACH RECORD
X                }
X
X                //T record
X                else if ( (lineNumber > 1) && (lineNumber < (totalLines - 1)) )
X                {
X                        char tRecord[60];
X                        int opRetr = 0;
X                        int addRetr = 0;
X                        memset(tRecord, 0, sizeof(tRecord)); // Reset array
X                        strcat(tRecord, "T");
X                        sprintf(hex, "%X", tempLocCtr);
X                        strcat(tRecord, "00");
X                        strcat(tRecord, hex);
X                        strcat(tRecord, "03");
X
X                        //IF SYMBOL IS DECLARED
X                        if ((lineCopy2[0] >= 65) && (lineCopy2[0] <= 90))
X                        {
X                                tokens = strtok(NULL, " \t\r\n");
X
X                                if (IsADirective(tokens) == 0)
X                                {
X                                       		opRetr = searchOpcode(tokens);
X                                        	if (opRetr == -1)
X                                        	{
X                                                	remove ("objectFile.obj");
X							lineNumber++;
X                                               		printf("\n PASS 2 ERROR NOT A VALID OPCODE\n");
X                                                	continue;
X                                        	}
X                                
X                                	sprintf(hex, "%2.2X", opRetr);
X                                	strcat(tRecord, hex);
X                                	tokens = strtok(NULL, " \t\r\n");
X                                	addRetr = searchSymTab(tokens, tab);
X                                	if (addRetr == 0)
X                                	{
X                                        	printf("SYMBOL DOES NOT EXIT4 IN TABLE");
X						remove ("objectFile.obj");
X						break;
X                                	}
X					boolCtr[lineNumber] = 1;		
X                              	  	sprintf(hex, "%X", addRetr);				
X                                	strcat(tRecord, hex);
X					boolCtr[lineNumber] = 1;
X				
X				} //UPDATED BRACKET TO ACCOUNT FOR DIRECTIVES
X				else
X				{
X
X					if( strcmp(tokens, "BYTE") == 0 ) {
X						tokens = strtok(NULL, " \t\r\n");
X						
X						if(tokens[0] == 'C'){	
X							char *temp = strtok( tokens, "C'" );
X							int intConv[60]; 
X							
X							for(int i = 0; i<strlen(temp); i++){
X								intConv[i] = (int) temp[i];
X								sprintf(hex,"%x",intConv[i]);
X								strcat(tRecord, hex);	
X							}
X
X						} else if (tokens[0] == 'X'  ){
X							char *temp = strtok ( tokens, "X'");
X							strcat(tRecord,temp );
X						}else{
X							remove ("objectFile.obj");
X							printf("\nASSEMBLY ERROR. NOT VALID OPERAND IN BYTE.\n");
X						}
X						boolCtr[lineNumber] = 0;
X
X					} else if(strcmp(tokens, "WORD") == 0 ){
X						int convInt; 
X						tokens = strtok(NULL, " \t\r\n");
X						convInt = atoi ( tokens );
X						sprintf(hex , "%6.6X" ,convInt );
X						strcat(tRecord, hex);
X					       boolCtr[lineNumber] = 0;	
X					} else if(strcmp(tokens, "RESB") == 0 ){
X						boolCtr[lineNumber] = 0;
X						lineNumber++;
X						continue;					
X					} else if(strcmp(tokens, "RESW") == 0 ){
X						boolCtr[lineNumber] = 0;
X						lineNumber++;
X						continue;
X					}else{}
X				}
X
X				fputs(tRecord, objFP);
X				fputs("\n", objFP); 
//				printf("\nT record: %s\n", tRecord);
X                        }
X                        //if line has no SYMBOL DECLARED
X                        else
X                        {
X
X                                if (IsADirective(tokens) == 0)
X                                {
X                                        opRetr = searchOpcode(tokens);
X                                        if (opRetr == -1)
X                                        {
X                                                lineNumber++;
X						remove ("objectFile.obj");
X                                                printf("\n PASS 2 ERROR NOT A VALID OPCODE\n");
X                                                continue;
X                                        }
X                                }
X                                //if a directive
X                                sprintf(hex, "%2.2X", opRetr);
X                                strcat(tRecord, hex);
X				if (opRetr == 76){
X					strcat(tRecord, "RSUB"); // doesnt matter
X					fputs(tRecord, objFP);
X                                	fputs("\n", objFP);
//					printf("\nT record: %s\n", tRecord);
X					boolCtr[lineNumber] = 0;
X					lineNumber++;
X					continue;	
X				}else if( opRetr == 80 || opRetr == 84){
X					tokens = strtok(NULL, ",");
X					addRetr = searchSymTab(tokens, tab);
X                                	if (addRetr == 0)
X                                	{
X						remove ("objectFile.obj");
X                                        	printf("SYMBOL DOES NOT EXIT IN TABLE");
X                                        	break;
X                                	}
X
X        	                        addRetr += 32768;
X                                	sprintf(hex, "%X", addRetr);
X                                	strcat(tRecord, hex);
X                                	
X					fputs(tRecord, objFP);
X                                	fputs("\n", objFP);
X					//printf("\nT record: %s\n", tRecord);
X					boolCtr[lineNumber] = 1;
X					lineNumber++;
X					continue;
X				}
X				tokens = strtok(NULL, " \t\r\n");
X                                addRetr = searchSymTab(tokens, tab);
X                                
X				if (addRetr == 0)
X                                {
X                                        printf("SYMBOL DOES NOT EXIT IN TABLE");
X                                        remove ("objectFile.obj");
X					break;
X                                }
X
X				boolCtr[lineNumber] = 1;
X                                sprintf(hex, "%X", addRetr);
X                                strcat(tRecord, hex);
X                                fputs(tRecord, objFP);
X				fputs("\n", objFP);
X
//				printf("\nT record: %s\n", tRecord);
X                        }
X                        //break;
X                }
X		
X		else {
X			int addRetr = 0;
X			eRecord[0] = '\0';
X			
X			strcat(eRecord, "E");
X			tokens = strtok(NULL, " \t\r\n");
X			tokens = strtok(NULL, " \t\r\n");
X			addRetr = searchSymTab(tokens, tab);
X			
X			if (addRetr == 0)
X			{
X				remove ("objectFile.obj");
X				printf("SYMBOL DOES NOT EXIT IN TABLE");
X                                break;
X			}
X			sprintf(hex, "%6.6X", addRetr);
X                        strcat(eRecord, hex);
X			fputs(eRecord, objFP);
X			fputs("\n", objFP);
//			printf("\nE record: %s\n", eRecord);
X			break;
X		}
X
X                lineNumber++;
X        }
X
X	for (int i = 1; i < totalLines; i++){
X		if ( boolCtr[i] == 1){
X			char mRecord[16];
X                	char hex2[7];
X                	memset(mRecord, '\0', 1024 * sizeof(char));
X                	strcat(mRecord, "M");
X                	sprintf(hex2, "%6.6X", (locCtrArr[i] + 1));
X                	strcat(mRecord, hex2);
X                	strcat(mRecord, "04" );
X                	strcat(mRecord, "+");		
X			strcat(mRecord, firstSym);
//			printf("\n Mod Record is: %s \n", mRecord);
X                	fputs(mRecord, objFP);
X                	fputs("\n", objFP);	
X		}
X	}
X	
X	fclose(objFP);
X        fclose(fp);
X
X	for (int i = 0; tab[i+1] != NULL; i++)
X	{
X		//free(tab[i]->Name);
X		free(tab[i]);
X        }
}
X
int isValidHex(char *hexString)
{
X        for (int i = 0; i < strlen(hexString); i++)
X        {
X                if (isxdigit(hexString[i]) == 0)
X                {
X                        return -1;
X                }
X        }
X        return 0;
}
X
int searchSymTab(char *tokens, SYMBOL *table[])
{
X        int result = 0;
X        //printf("\nTokens: %sEND \n", tokens);
X
X        for (int i = 1; table[i+1] != NULL; i++){
X
X                if (strcmp(table[i]->Name, tokens) == 0)
X                {
X                        result = table[i]->Address;
X                }
X        }
X
X        return result;
}
SHAR_EOF
  (set 20 21 10 25 20 43 25 'main.c'
   eval "${shar_touch}") && \
  chmod 0644 'main.c'
if test $? -ne 0
then ${echo} "restore of main.c failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'main.c': 'MD5 check failed'
       ) << \SHAR_EOF
68914b6aa367fc255a2401c94c8ae82f  main.c
SHAR_EOF

else
test `LC_ALL=C wc -c < 'main.c'` -ne 23825 && \
  ${echo} "restoration warning:  size of 'main.c' is not 23825"
  fi
fi
# ============= symbols.c ==============
if test -n "${keep_file}" && test -f 'symbols.c'
then
${echo} "x - SKIPPING symbols.c (file already exists)"

else
${echo} "x - extracting symbols.c (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'symbols.c' &&
#include "headers.h"
X
X
X
int IsAValidSymbol( char *TestSymbol ){
X
X	int Result = 1;
X	int index = 0;
X	int maxlength = 6;
X	int done;
X	done = 0 ;
X
X	while( !done ) {
//		printf("\nIs digit is : %c\n", TestSymbol[index]);
X		if ( TestSymbol[index] == '\0' ) {
X			break;
X		}
X		if( isalnum(TestSymbol[index]) == 0 ){
X
X	          	printf("ASSEMBLY ERROR. Charecter in Symbol %s is invalid " ,TestSymbol);
X
X			Result = 0;
X			break;
X		}
X		if(IsADirective(TestSymbol) == 1){
X			done = 1;
X			Result = 0;
X		}
X		if ( index == maxlength ) {
X			done = 1;
X			Result = 0;
X		}
X		index++;
X
X	}
X
/*	if(!(isalpha(TestSymbol)) || !(isdigit(TestSymbol)) ){
X   		 Result = 0;
X  	}
*/
X	return Result;
}
X
void addSymToTab(int addr, char *sname, SYMBOL *table[]) {
X  	int index = 0;
X  	SYMBOL *newsym;
X
X 	newsym = malloc(sizeof(SYMBOL));
X  	newsym -> Address = addr; //inside newsym set Address to Addr Obj.property = 100; 
X 	strcpy(newsym -> Name, sname);
X
X  	while(table[index] != NULL){
X		index++;
X	}
X
X	table[index] = newsym;
X
}// int return of index 
X
int checkIfSymbolExits(SYMBOL *tab[], char *sname){
X	int resuct = 0;
X	int index = 0;
X
X	while(tab[index]!= NULL){
X		if(strcmp(sname,tab[index]->Name) == 0){
X			resuct = -1;
X			break;
X		}
X		index++;
X	}
X
X	return resuct;
}
SHAR_EOF
  (set 20 21 10 20 20 56 48 'symbols.c'
   eval "${shar_touch}") && \
  chmod 0644 'symbols.c'
if test $? -ne 0
then ${echo} "restore of symbols.c failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'symbols.c': 'MD5 check failed'
       ) << \SHAR_EOF
6ec327d4f3d4b13cbd507a3b493492c6  symbols.c
SHAR_EOF

else
test `LC_ALL=C wc -c < 'symbols.c'` -ne 1243 && \
  ${echo} "restoration warning:  size of 'symbols.c' is not 1243"
  fi
fi
# ============= headers.h ==============
if test -n "${keep_file}" && test -f 'headers.h'
then
${echo} "x - SKIPPING headers.h (file already exists)"

else
${echo} "x - extracting headers.h (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'headers.h' &&
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
X
X
typedef struct symbols {
X	int	DefinedOnSourceLine;
X	int	Address; 
X	char	Name[7]; } Symbol;
X
typedef struct symbols	SYMBOL;
X
struct opcode {
X	int	OpCode;	
X	char	Name[8];
X
};
X
typedef struct opcode OPCODE;
X
X
OPCODE OpcodeTable[ 59 ];
X
int IsAnInstruction( char *Test );
int IsAValidSymbol( char *TestSymbol );
int IsADirective( char *Test );
int isValidHex( char *hexString );
int hanStart( char *start, char *startAddr, char lineCopy[1024], int numLine );
int checkIfSymbolExits(SYMBOL *tab[], char *sname);
void addSymToTab(int addr, char *sname, SYMBOL *table[]);
void fixHexLength();
void fixCharLength();
void addTrecord();
int searchSymTab(char *tokens, SYMBOL *table[]);
int searchOpcode(char *opCode);
SHAR_EOF
  (set 20 21 10 17 17 37 27 'headers.h'
   eval "${shar_touch}") && \
  chmod 0644 'headers.h'
if test $? -ne 0
then ${echo} "restore of headers.h failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'headers.h': 'MD5 check failed'
       ) << \SHAR_EOF
68550c863c4acfc407099bf20e571314  headers.h
SHAR_EOF

else
test `LC_ALL=C wc -c < 'headers.h'` -ne 788 && \
  ${echo} "restoration warning:  size of 'headers.h' is not 788"
  fi
fi
# ============= documentation.txt ==============
if test -n "${keep_file}" && test -f 'documentation.txt'
then
${echo} "x - SKIPPING documentation.txt (file already exists)"

else
${echo} "x - extracting documentation.txt (text)"
  sed 's/^X//' << 'SHAR_EOF' | uudecode &&
begin 600 documentation.txt
M37D@:6UP;&5M96YT871I;VX@;V8@4&%S<R`R(&EN8VQU9&5S('=A>7,@=&\@
M:&%N9&QE('1H92!-;V1I9FEC871I;VXL(%1E>'0L($AE861E<B!A;F0@16YD
M(')E8V]R9',N($)Y('5S:6YG('-T<F-M<"!A;F0@82!M=6QT:71U9&4@;V8@
M:68M96QS92!S=&%T;65N=',L($D@9&5T97)M:6YE('=H:6-H('1Y<&4@;V8@
M<G)E8V]R9"!N965D<R!T;R!B92!C;VYS=')U8W1E9"!A;F0@=7-I;F<@<W1R
M:6YG(&-O;F-A=&5N871I;VX@86YD('-P<FEN=&9S('1O(&-H86YG92!I;G1E
M9V5R<R!I;G1O(&AE>"!C:&%R96-T97)S+B!)(&%L<V\@<&]P=6QA=&5D('1H
M92!,;V-A=&EO;B!#;W5N=&5R(&EN=&\@87)R87D@86YD(&-O;F-A=&5N871E
M("!I="!I;G1O('=H:6-H979E<B!I;G-T86YC92!N965D960N(`H*22!D:60@
M=')Y('9E<GD@:&%R9"!T;R!B<F5A:R!D;W=N('1E>'0@<F5C;W)D<R!I;G1O
M(&1I9F9E<F5N="!L:6YE<R!O;F-E('1H92!L96YG=&@@97AT96YD<R`S,2!C
M:&%R(&QO;F<@8G5T($D@:&%D('1O(&=O(&)A8VL@=&\@86X@;VQD('9E<G-I
M;VX@;V8@;7D@8V]D92!W:71H;W5T(&ET(&%S(&ET('=O=6QD(&5R<F]R(&]U
M="!A;F0@;F]T(&=I=F4@=&AE(&-O<G)E8W0@=&5X="!R96-O<F0N($1U92!T
M;R!T:&ES(&ET(&9A:6QS('1E<W0@8V%S97,@.2!A;F0@,3`@8G5T('!A<W-E
M<R!T:&4@<F5S="X@1G5T:')E;6]R92P@=V4@<W!O:V4@86)O=70@9G)E96EN
M9R!T:&4@=&%B;&5;:5TM/DYA;64@<&]I;G1E<B!B=70@:70@=V]U;&1N)W0@
M9G)E92!U<"!A;GD@<W!A8V4@86YD(&-A=7-E(&$@<V5G;65N=&%T:6]N(&9A
M=6QT(&EN('1E<W0@8V%S92`W+B!"=70@<F5M;W9I;F<@=&AA="!A;&QO=V5D
M(&9O<B!M92!T;R!C871C:"!T:&%T(&5R<F]R+B!);B!S;VUE('=A>7,L($D@
M=VES:"!F;W(@=&AE('-A:V4@;V8@<W1R=6-T=7)E('1H870@22!C;VYS=')C
M=71E9"!P<V5U9&]C;V1E('1H870@=V]U;&0@86QL;W<@;64@=&\@<F5D=6-E
M(')E<&5A=&5D(&-O9&4@:6X@=&AE(%0M<F5C;W)D<R!B=70@4&%S<R`R(&AE
M;'!E9"!M92!T;R!L96%R;B!O;B!T:&4@9V\@=VAI8V@@:7,@:&]W(&QI;6ET
M871I;VYS(&]C8W5R960@=VAE;B!T<GEI;F<@=&\@<V5P97)A=&4@;&EN92X*
<"D5M86YU96P@5&5S9F$@"DXP,3`U.#4R.0H*"F\@
`
end
SHAR_EOF
  (set 20 21 10 25 21 31 39 'documentation.txt'
   eval "${shar_touch}") && \
  chmod 0644 'documentation.txt'
if test $? -ne 0
then ${echo} "restore of documentation.txt failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'documentation.txt': 'MD5 check failed'
       ) << \SHAR_EOF
a6a209f357316f8aebf0bd199ee1f33a  documentation.txt
SHAR_EOF

else
test `LC_ALL=C wc -c < 'documentation.txt'` -ne 1153 && \
  ${echo} "restoration warning:  size of 'documentation.txt' is not 1153"
  fi
fi
# ============= makefile ==============
if test -n "${keep_file}" && test -f 'makefile'
then
${echo} "x - SKIPPING makefile (file already exists)"

else
${echo} "x - extracting makefile (text)"
  sed 's/^X//' << 'SHAR_EOF' > 'makefile' &&
project1:	main.o symbols.o  directives.o headers.h
X	gcc -g -o project1 -Wall  -O0 main.o symbols.o directives.o instructions.c
X
main.o:	main.c headers.h 
X	gcc -c -Wall  -O0 -g main.c
X
symbols.o:	symbols.c headers.h
X	gcc -c -Wall  -O0 -g symbols.c
X
directives.o:	directives.c headers.h
X	gcc -c -Wall  -O0 -g directives.c
X
instructions.o:   instructions.c headers.h
X	gcc -c -Wall  -O0 -g instructions.c
X
clean:	
X	rm *.o -f
X	touch *.c
X	rm project1 -f
SHAR_EOF
  (set 20 21 10 19 15 10 14 'makefile'
   eval "${shar_touch}") && \
  chmod 0644 'makefile'
if test $? -ne 0
then ${echo} "restore of makefile failed"
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'makefile': 'MD5 check failed'
       ) << \SHAR_EOF
d89dc5e79d1e1b871f2a071dcd7e8654  makefile
SHAR_EOF

else
test `LC_ALL=C wc -c < 'makefile'` -ne 448 && \
  ${echo} "restoration warning:  size of 'makefile' is not 448"
  fi
fi
if rm -fr ${lock_dir}
then ${echo} "x - removed lock directory ${lock_dir}."
else ${echo} "x - failed to remove lock directory ${lock_dir}."
     exit 1
fi
exit 0
